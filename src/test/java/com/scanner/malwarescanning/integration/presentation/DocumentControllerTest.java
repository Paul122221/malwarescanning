package com.scanner.malwarescanning.integration.presentation;

import com.scanner.ScannerApplication;
import com.scanner.malwarescanning.domain.entity.AccountImpl;
import com.scanner.malwarescanning.domain.entity.DocumentImpl;
import com.scanner.malwarescanning.domain.service.AccountService;
import com.scanner.malwarescanning.domain.service.DocumentService;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.*;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

import static org.junit.jupiter.api.Assertions.assertEquals;


/**
 * This test evaluates the business logic of the application by examining three file upload scenarios
 * within the DocumentControllerTest. It includes one successful file upload and two failed uploads due
 * to files not meeting specified criteria. The test is conducted in a Spring Boot environment with random
 * port configuration.
 */
@SpringBootTest(
        classes = ScannerApplication.class,
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
@ActiveProfiles("test")
public class DocumentControllerTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    @Qualifier(value = "InMemoryPDFDocumentService")
    private DocumentService documentService;

    @Autowired
    AccountService accountService;

    /**
     * In this scenario, a user successfully uploads and saves a valid file. The file meets all required criteria,
     * passes validation checks, and is correctly stored by the server.
     */
    @Test
    public void testSuccessDocumentSaving() throws IOException {
        File file = Files.createTempFile("",".pdf").toFile();
        PDDocument document = new PDDocument();
        PDPage page = new PDPage();
        document.addPage(page);

        PDPageContentStream contentStream = new PDPageContentStream(document, page);
        contentStream.beginText();
        contentStream.setFont(PDType1Font.HELVETICA, 12);
        contentStream.showText("Hello World");
        contentStream.endText();
        contentStream.close();
        document.save(file);

        Resource fileResource = new FileSystemResource(file);
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", fileResource);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        ResponseEntity<DocumentImpl> response = restTemplate.postForEntity("/document", requestEntity, DocumentImpl.class);
        assertEquals(HttpStatusCode.valueOf(200), response.getStatusCode());
        documentService.deleteAll();
    }


    /**
     * In this scenario, a user attempts to upload a file labeled as a PDF, but it fails validation because
     * its magic bytes don't match those of a genuine PDF. Consequently, the server responds with a BadRequest
     * status code, indicating the file format inconsistency.
     */
    @Test
    public void testFailOnFakePDFFile() throws IOException {

        Path filePath = Files.createTempFile("","pdf");
        String content = "Hello, world!";


        Files.writeString(filePath, content, StandardOpenOption.CREATE);
        File file = filePath.toFile();

        Resource fileResource = new FileSystemResource(file);
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", fileResource);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        ResponseEntity<String> response = restTemplate.postForEntity("/document", requestEntity, String.class);
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        documentService.deleteAll();
    }


    /**
     * In this scenario, a user attempts to save a PDF file containing an IBAN (International Bank Account Number)
     * that is listed in a blacklist, indicating it's banned. The server, detecting the blacklisted IBAN in the PDF,
     * prevents the file from being saved.
     */
    @Test
    public void testFailOnBannedIBAN() throws IOException {

        String iban = "DE15300606010505780780";
        AccountImpl account = new AccountImpl();
        account.setIban(iban);
        account.setBlocked(true);
        accountService.save(account);

        File file = Files.createTempFile("","pdf").toFile();
        PDDocument document = new PDDocument();
        PDPage page = new PDPage();
        document.addPage(page);

        PDPageContentStream contentStream = new PDPageContentStream(document, page);
        contentStream.beginText();
        contentStream.setFont(PDType1Font.HELVETICA, 12);
        contentStream.showText("IBAN DE15300606010505780780");
        contentStream.endText();
        contentStream.close();
        document.save(file);

        Resource fileResource = new FileSystemResource(file);
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", fileResource);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        ResponseEntity<String> response = restTemplate.postForEntity("/document", requestEntity, String.class);
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());

        documentService.deleteAll();
    }
}
